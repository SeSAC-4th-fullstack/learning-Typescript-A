# chapter 9. 타입 제한자

# top 타입

- 시스템에서 가능한 모든 값을 나타내는 타입
- 모든 다른 타입의 값은 타입이 `top`인 위치에 제공 가능
  → 모든 타입은 `top` 타입에 할당 가능

## any

- 모든 타입의 위치에 제공될 수 있다는 점에서 `top` 타입처럼 작동 가능
- 일반적으로 `consol.log`의 매개변수와 같이 모든 타입의 데이터를 받아들이는 위치에서 사용

```tsx
let v: any;
v = "hi";
v = 123;

console.log(v);
```

- TS가 해당 값에 대한 할당 가능성 또는 멤버에 대해 타입 검사를 수행하지 않도록 하는 문제점이 존재
  → 안전성 부족
  → 타입 검사기를 빠르게 건너뛰려고 할 때 유용하지만 타입 검사를 비활성화하면 해당 값에 대한 TS의 유용성이 줄게 됨
  → 어떤 값이든 될 수 있음을 나타낼 때는 `unknown`타입이 적합

## unknown

- `top` 타입
- 모든 객체를 `unknown` 타입의 위치로 전달할 수 있다는 점에서 `any` 타입과 유사
- `unknown` 타입의 값을 훨씬 더 제한적으로 취급
- `unknown` 타입 값의 속성에 직접 접근 불가
- `top` 타입이 아닌 타입에는 할당 불가
- TS가 `unknown` 타입에 접근할 수 있는 유일한 방법은 `instanceof`나 `typeof` 또는 타입 어셔션을 사용하는 것처럼 값의 타입이 제한된 경우

# 타입 서술어

- 인수가 특정 타입인지 여부를 나타내기 위해 `boolean` 값을 반환하는 함수를 위한 특별한 구문
- 사용자 정의 타입 가드라고도 불림
- 일반적으로 매개변수로 전달된 인수가 매개변수의 타입보다 더 구체적인 타입인지 여부를 나타내는데 사용
- 타입 서술어의 반환 타입은 매개변수의 이름, `is` 키워드, 특정 타입으로 선언 가능

```tsx
function typeP(input: WideType): input is NarrowType;
```

- 단순히 `boolean` 값을 반환하는 것이 아니라 인수가 더 구체적인 타입임을 나타내는 것
- 인터페이스의 인스턴스로 알려진 객체가 더 구체적인 인터페이스의 인스턴스인지 여부를 검사하는데 자주 사용됨
- `false` 조건에서 타입을 좁힘
  → 타입 서술어가 입력된 타입 이상을 검사하는 경우 예상치 못한 결과가 나올 수 있음
- 속성이나 값의 타입을 확인하는 것 이상을 수행해 잘못 사용하기 쉽기 대문에 가능하면 피하는 것이 좋음
- 대부분은 간단한 타입 서술어만으로도 충분

# 타입 연산자

## keyof

- JS의 객체는 일반적으로 `string` 타입인 동적 값을 사용하여 검색된 멤버를 갖음
  → TS에서 이러한 키를 표현하려면 까다로움
  → `string` 같은 포괄적인 원시 타입을 사용하면 컨테이너 값에 대해 유효하지 않은 키가 허용됨
- 해당 타입에 허용되는 모든 키의 조합을 반환하는 연산자
- 존재하는 타입의 키를 바탕으로 유니언 타입을 생성하는 기능

## typeof

- 제공되는 값의 타입 반환
- 값의 타입을 수동으로 작성하는 것이 복잡한 경우 사용 시 유용
- JS의 `typeof`가 아님
  → 타입에 대한 문자열의 이름을 반환하는 런타임 연산
- TS에서만 사용 가능하며 JS 코드에는 나타나지 않음

### keyof, typeof

- 두 키워드를 연결해 값의 타입에 허용된 키를 간결하게 검색 가능

# 타입 어서션

- 값의 타입에 대한 타입 시스템의 이해를 재정의하기 위한 구문
- 타입 캐스트라고도 부름
- 다른 타입을 의미하는 값의 타입 다음에 as 키워드를 배치
- 타입 시스템은 어서션을 따르고 값을 해당 타입으로 처리

```tsx
const arr = '["hi", "hello"]';

//타입: any
JSON.parse(arr);

//타입: string[]
JSON.parse(arr) as string[];

//타입: [string, string]
JSON.parse(arr) as [string, string];

//타입: ["hi", "hello"]
JSON.parse(arr) as ["hi", "hello"];
```

- TS 타입 시스템에만 존재
- JS로 컴파일 시 다른 타입 시스템 구문화 함께 제거

## 포착된 오류 타입 어서션

- 오류 처리시 유용함
- 코드 영역이 `Error` 클래스의 인스턴스를 발생시킬거라 확신한다면 타입 어서션을 사용해 포착된 어서션을 오류로 처리 가능
- 발생된 오류가 예상된 오류 타입인지를 확인하기 위해 `instanceof` 검사와 같은 타입 내로잉을 사용하는 것이 더 안전함

### non-null 어서션

- 이론상으로 `null` 또는 `undefined`를 포함할 수 있는 변수에서 `null`과 `undefiend`를 제거할 때 타입 어서션을 주로 사용
- `null`과 `undefined`를 제외한 값의 전체 타입을 작성하는 대신 !를 사용하면 됨
  → non-null 어서션은 타입이 `null` 또는 `undefined`가 아니라고 간주
- 값을 반환하거나 존재하지 않는 경우 `undefined`를 반환하는 Map.get과 같은 API에서 유용함

## 주의 사항

- 타입 어서션은 `any` 타입과 마찬가지로 타입 시스템에 필요한 하나의 도피 수단
  → 꼭 필요한 경우가 아니라면 사용 자제
- 값의 타입에 대해 더 쉽게 어서션하는 것보다 코드를 나타내는 더 정확한 타입을 갖는 것이 좋음

### 어서션 vs. 선언

- 어서션: 타입 검사 중 일부를 건너뛰도록 지시
- 선언: 타입 검사기는 변수 타입 애너테이션에 대한 변수의 초깃값에 대해 할당 가능성 검사를 수행

→ 타입 애너테이션을 사용하거나 초깃값에서 변수의 타입을 유추하도록 하는 것이 바람직함

### 어서션 할당 가능성

- 일부 값의 타입이 잘못된 상황에서 필요한 도피 수단
- TS는 타입 중 하나가 다른 타입에 할당 가능한 경우에만 두 타입 간의 타입 어서션을 허용
- 완전히 서로 관련이 없는 두 타입 사이에 타입 어서션이 있는 경우, 타입 오류를 감지하고 알려줌

# const 어서션

- 배열, 원시 타입, 값, 별칭 등 모든 값을 상수로 취급해야 함을 나타내는데 사용
- 특히 `as const`는 수신하는 모든 타입에 다음 세가지 규칙 적용
  1. 배열은 가변 배열이 아니라 읽기 전용 튜플로 취급
  2. 리터럴은 일반적인 원시 타입과 동등하지 않고 리터럴로 취급
  3. 객체의 속성은 읽기 전용으로 간주됨

### 리터럴에서 원시 타입으로

- 리터럴 값을 일반적으로 원시 타입으로 확장하기보다 특정 리터럴로 이해하는 것이 유용
- 값의 특정 필드가 더 구체적인 리터럴 값을 갖도록 하는 것이 유용
  → 인기 있는 라이브러리는 값의 판별 필드가 특정 리터럴이 되도록 요규
  → 해당 코드의 타입이 값을 더 구체적으로 추론 가능

### 읽기 전용 객체

- 변수 초깃값으로 사용되는 것과 같은 객체 리터럴은 `let` 변수의 초깃값이 확장되는 것과 동일한 방식으로 속성 타입을 확장
  → 값의 일부 또는 전체를 나중에 특정 리터럴 타입이 필요한 위치에서 사용해야 할 때 오류 발생 가능성 존재
- `as const`를 사용해 값 리터럴을 어서션하게 되면 리터럴은 일반적인 원시 타입 대신 고유한 리터럴 타입으로 간주되며, 배열은 읽기 전용 튜플이 됨
  → 값 리터럴에 `const` 어서션을 적용하면 해당 값 리터럴이 변경되지 않고 모든 멤버에 동일한 `const` 어서션 로직이 재귀적으로 적용됨
