[Chapter9] 타입 제한자
======================
# 9.1. top 타입
top 타입은 시스템에서 가능한 모든 값을 나타내는 타입입니다. 모든 다른 타입의 값은 타입이 top인 위치에 제공 될 수 있습니다. 즉, 모든 타입은 top 타입에 할당 할수 있습니다. 
## 9.1.1 클래스 속성
any타입은 모든 타입의 위치에 제공 될 수 있다는 점이 top 타입처럼 작동합니다. any는 타입 스크립트가 해당 값에 대한 할당 가능성 및 멤버에  대한 타입 검사를 수행 하지 않도록 지시 한다는 문제점을 갖습니다. 타입을 비활성화합면 해당 값에 대한 타입스크립트의 유용성이 줄어듭니다.
## 9.1.2 unknown
타입스크립트에서 unknown은 진정한 top 타입입니다. 모든 객체를 unknown 타입의 위치로 전달 할 수 있다는 점이 any타입과 유사합니다.
   * 타입스크립트는 unknown 타입 값의 속성에 직접 접근 가능합니다.
   * unknown 타입은 top 타입이 아닌 타입에는 할당 불가합니다.
```javascript
   function greet(name : unknown) {
      console.log('Announcing ${name.toUpperCase()}!')
   } //Error : Object is of type 'unknown'
```
다음 unknown 타입의 접근 방식으로는 instanceof 나 typeof 또는 타입 어서션을 사용하는것처럼 값의 타입이 제한된 경우입니다. 가능한 any 보다는 unknown을 추천합니다.
# 9.2. 타입 서술어
 instanceof, typeof 와같은 같은 구문은 직접 제한된검사로 사용할때는 좋지만, 로직을 함수로 감싸면 좁힐 수 없습니다.
 타입스크립트에는 인수가 특정 인수인지 아닌지 구분하기위해 boolean 값을 반환하는 함수를 위한 특별한 구문이 있습니다. 이를 타입 서술어 라고 하며, 사용자 정의 타입 가드라고도 부릅니다.
# 9.3. 타입 연산자
기존 타입의 속성 일부를 변환해서 두 타입을 결합해 새로운 타입을 생성해야할 때도 있습니다.
## 9.3.1 keyof
자바스크립트 객체는 일반적으로 string 타입인 동적 값을 사용하여 검색된 멤버를 찾습니다.(무조건x) 타입시스템에서 이러한 키를 표현하려면 상당히 까다로워, string 같은 포괄적인 원시 타입을 사용하면 컨테이너 값에 대한 유효하지 않은 키가 허용됩니다. 
## 9.3.2 typeof 
타입스크립트에서는 제공되는 값의 타입을 수동으로 작성하는 것이 복잡한 경우에 매우 유용합니다. typeof 타입 연산자는 시각적으로 주어진 값이 어떤 타입인지를 반환할때 사용하는런타임 typeof 연산자처럼 보이지만 이둘은 차이가 있습니다. 자바스크립트의 typeof 연산자는 타입에 대한 문자열 이름을 반환하는 런타임 연산이라는것을 기억하세요.

### keyof typeof
typeof는 값의 타입을 검색하고, keyof는 타입에 허용된 키를 검색합니다. 타입스크립트는 두 키워드를 함께 연결해 값의 타입에 허용된 키를 간결하게 검색 가능합니다. 

## 9.4. 타입 어서션
타입스크립트는 코드가 강력하게 타입화 될때 가장 잘 작동합니다. 즉, 코드의 모든 값이 정확히 알려진 타입을 가지는 경우입니다. 타입스크립트는 top타입과 타입가드 같은 기능을 제공합니다.

## 9.4.1. 포착된 오류 타입 어서션
오류를 처리할때 타입 어서션은 매우 유용합니다. try 블록의 코드가 예상과 다른 객체를 예기치 않게 발생할 수 있기 때문에 catch 블록에서 포착된 오류가 어떤 타입인지 아는것은 불가능합니다. 발생된 오류가 어떤 타입인지 알기위해 instanceof 검사와 같은 타입 내로잉을 사용하는것이 좋습니다.

## 9.4.2. non-null 어서션
타입 어서션이 유용한 경우는 null / undefined 를 포함할 수 있는  변수에서 제거할때 주로 사용합니다. 전체 타입을 작성하는대신 !를 작성합니다.
Map.get 과 같은 API에서 유용합니다.

## 9.4.3. 타입 어서션 주의 사항
any 타입과 마찬가지로 타입 어서션은 타입시스템에 필요한 하나의 도피 수단입니다. any타입을 사용할때처럼 꼭 필요한 경우가 아니라면 가능한 사용하면 안됩니다. non-null 어서션은 여전히 코드가 타입검사를 통과하도록 만들지만 런타입 오류가 발생할수도 있습니다.

## 어서션 vs 선언
변수 타입을 선언하기 위해 타입 애너테이션을 사용하는것과 초깃값으로 변수 타입을 변경하기 위해 타입 어서션을 사용하는것 사이에는 차이가 있습니다. 

## 어서션 할당 가능성
타입 어서션을 허용하는경우는 타입중 하나가 다른 타입에 할당 가능한 경우에만 가능합니다. 하나의 타입에서 값을 완전히 관련 없는 타입으로 전환해야 하는 경우 이중 타입 어서션을 사용합니다. 먼저 any / unknown 같은 top 타입으로 전환후 그결과를 관련없는 타입으로 전환합니다.
```javascript
  let myValue = "Stella!" as number;
  // Error
```

```javascript
  let myValueDouble = "1337" as unknown as number;
```
as known as... 이중 타입 어서션은 위험하고 항상 코드의 타입이 잘못되었다는 징후를 나타냅니다. 타입 시스템의 도피 수단으로 이중 타입 어서션을 사용하면, 주변 코드를 변경해 이전에 작동하던 코드에 문제가 발생한경우 타입스크립트는 구해주지 못함을 의미합니다.

## 9.5. const 어서션
const 어서션은 배열, 원시타입, 값, 별칭 등 모든 값을 상수로 취급해야함을 나타내는데 사용합니다. 특히 as const 는 수신하는 모든 타입에 세가지 규칙을 적용합니다.
   * 배열은 가변 배열이 아니라 읽기 전용 튜플로 취급합니다.
   * 리터럴은 일반적인 원시 타입과 동등하지 않고 리터럴로 취급합니다.
   * 객체의 속성은 읽기 전용으로 간주됩니다.
 ```javascript
  [0, ''];
  // 타입 : (number | string)[]
  [0, ''] as const;
  //타입 : readonly[0, '']
``` 
## 9.5.1. 리터럴에서 원시 타입으로
타입 시스템이 리터럴 값을 일반적인 원시 타입으로 확장 하기 보다 특정 리터럴로 이해하는 것이 유용할 수 있습니다.
예를 들어 튜플을 반환하는 함수처럼 일반적인 원시 타입 대신 특정 리터럴을 생성한다고 알려진 함수에서 유용할 수 있습니다.

## 9.5.2. 읽기 전용 객체
변수의 초깃값으로 사용되는 객체 리터럴은 let 변수의 초깃값이 확장되는 것과 함께 속성 타입을 확장합니다. apple 과 문자열은 string 과 같은 원시 타입이 되고, 배열은 튜플이 아닌 array 타입이 됩니다. 하지만 이러한 값의 일부 또는 전체를 특정 리터럴 타입이 필요한 위치에서 사용해야 할때 잘맞지 않을 수 있습니다.
